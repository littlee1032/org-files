* What is scala? Why scala?
** What is scala
*** scale language: scripts -> big system
**** seamless cooperate with java
**** static type + OOP + FP
** Why scala
*** consie: less words, consie meaning
    val capital = Map("US" -> "Washington")
    capital += ("Japan" -> "Tokyo")
    println(capital("US"))
*** flexible: less word change
*** barzaar: (cathedral vs barzaar)
**** new type
     def factorial(x: BigInt): BigInt =
         if (x == 0) 1 else x * factorial(x-1)
**** new control
     actor {
         var sum = 0
         loop {
             receive {
                 case Data(bytes) => sum += hash(bytes)
                 case GetSum(requester) => requester ! sum
             }
         }
     }
* Learn scala
** Value and variable
   val msg = "Hello World"
   var msg = "Hello World"
** Function
   def max(x: Int, y: Int): Int = {
       if (x > y) x
       else y
   }
   def max(x: Int, y: Int) = if (x > y) x else y
** Scripts
   #!/bin/sh
   exec scala "$0" "$@"
   !#
   println("Hello World")
** Loop
   var i=0
   while (i < args.length) {
       println(args(i))
       i += 1
   }
   args.foreach((arg: String) => println(arg))
   args.foreach(println)
** Parameterize arrays (mutable)
   val greetStrings = new Array[String](3)
   greetStrings(0) = "....." ....
   for (i <- 0 to 2)
     print(greetStrings(i))
   val numNames = Array("zero", "one", "two")
** List (immutable)
   val oneTwoThree = List(1, 2, 3)
   val four = List(4)
   val oneTwoThreeFour = oneTwoThree ::: four
   val oneTwoThree = 1 :: List(2, 3) = 1 :: 2 :: 3 :: Nil

   val thrill = "Will" :: "fill" :: "until" :: Nil
   thrill(2)
   thrill.count(s=>s.length == 4)
   thrill.drop(2)
   thrill.dropRight(2)
   thrill.exists(s=>s == "until")
   thrill.filter(s=>s.length == 4)
   thrill.forall(s=>s.endsWith("l"))
   thrill.foreach(s=>print(s)) ....
** Tuple (immutable)
   val pair = (99, "ninetynine")
   println(pair._1)
   println(pair._2)
** Sets and maps
*** Sets
**** scala.collection.immutable.Set, scala.collection.mutable.Set
**** scala.collection.immutable.HashSet, scala.collection.mutable.HashSet
     var jetSet = Set("Boeing", "Airbus")
     jetSet += "Aaaa"

     val movieSet = Set("Despicable Me", "Singing in the Rain")
     movieSet += "Flipped"
*** Map
**** scala.collection.immutable.Map, scala.collection.mutable.Map
**** scala.collection.immutable.HashMap, scala.collection.mutable.HashMap
     import scala.collection.mutable.Map
     val treasureMap = Map[Int, String]()
     treasureMap += (1 -> "Go to island.")
     treasureMap += (2 -> "Find big X on ground")
     treasureMap += (3 -> "Dig.")
** Functional style
   def printArgs(args: Array[String]): Unit = {
       var i = 0
       while (i < args.length) {
           println(args(i))
           i += 1
       }

       for (arg <- args)
           println(arg)

       args.foreach(println)
   }

** Classes, fields and methods
   class A {
       .....
   }
   val a = new A
   class A {
       private var sum = 0
       def add(b: Byte): Unit = {
           b = 1 //won't compile
           sum += b
       }

       def add(b: Byte): Unit = sum += b
       def add(b: Byte) { sum += b }
   }
** Singleton object
*** classes in Scala can not have static members. Scala has singleton objects
    object A {
        def someMethod() : Unit {
        }
    }
** Functions and Closures
*** Methods
*** Local functions (another solution for private)
    def processFile(filename: String, width: Int) {
      def processLine(filename: String/*, width: Int, line: String*/) {
        if (line.length > width)
          println(filename + ": " + line)
      }
      val source = Source.fromeFile(filename)
      for (line <- source.getLines()) {
        processLine(filename, width, line)
      }
    }
*** First-class functions
    var increase = (x: Int) => x + 1
    increase(10)
*** Short forms of function literals
    someNumbers.filter((x: Int) => x > 0)
    someNumbers.filter((x) => x > 0) (target typing)
    someNumbers.filter(x => x > 0)
*** Placeholder syntax
    someNumber.filter(_ > 0)
    val f = _ + _ (What's this?)
    val f = (_: Int) + (_:Int)
*** Parially applied functions
    def sum(a: Int, b: Int, c: Int) = a+b+c
    val a = sum _
    a(1, 2, 3)  // a.apply(1, 2, 3)
    val b = sum(1, _: Int, 3)
    b(2)
*** Closures
    var more = 1
    val addMore = (x: Int) => x + more
    addMore(10) // 11
    more = 9999
    addMore(10) // 10009

    val someNumbers = List(-11, -10, -5, 0 , 5, 10)
    var sum = 0
    someNumbers.foreach(sum += _)

    def makeIncreaser(more: Int) = (x: Int) => x + more
    makeIncreaser(10)
    makeIncreaser(1000)
*** Special function call forms
**** Repeated parameters
     def echo(args: String*) =
       for (arg <- args) println(arg)
**** Named arguments
     def speed(distance: Float, time: Float): Float = distance / time
     speed(distance = 100, time = 100)
     speed(time = 10, distance = 100)
**** Default parameter values
     def printTime(out: java.io.PrintStream = Console.out) = 
       out.println("time = " + System.currentTimeMillis())
*** Tail recursion
    def approximate(guess: Double): Double =
      if (isGoodEnough(guess)) guess
      else approximate(improve(guess))

    def bang(x: Int): Int =
      if (x == 0) throw new Exception("bang!")
      else bang(x-1)

    -g:notailcalls

**** limited: indirect, method rename
** Control Abstraction
*** high order function
   high order function ---> more oppotunity for reducing code duplication
   search problem:
   object FileMatcher {
     private def filesHere = (new java.io.File(".")).listFiles
     def filesEnding(query: String) =
       for (file <- filesHere; if file.getName.endsWith(query))
         yield file

     def filesContaining(query: String) = 
       for (file <- filesHere; if file.getName.contains(query))
         yield file

     def filesRegex(query: String) =
       for (file <- filesHere; if file.getName.matches(query))
         yield file
   }

   def fileMatching(query: String, method) =
     for (file <- filesHere; if file.getName.method(query))
       yield file

   Scala can not do this......

   def filesMathing(query: String, matcher: (String, String) => Boolean) = {
     for (file <- filesHere; if matcher(file.getName, query))
       yield file
   }

   def fileEnding(query: String) =
     filesMatching(query, _.endsWith(_))

   def containsNeg(name: List[Int]): Boolean = {
     var exists = false
     for (num <- nums)
       if (num < 0)
         exists = true
     exists
   }

   def containsNeg(nums: List[Int]) = nums.exists(_ < 0)

*** Curring
    def plainOldSum(x: Int, y: Int) = x + y

    def curriedSum(x: Int)(y: Int) = x + y

    def withPrintWriter(file: File, op: PrintWriter => Unit) {
      val writer = new PrintWriter(file)
      try {
        op(writer)
      } finally {
        writer.close()
      }
    }

    withPrintWriter(
      new File("data.txt"),
      writer => writer.println(new java.util.Date)
    )

    println {"Hello, world!"}

    val file = new File("data.txt")
    withPrintWriter(file) {
      writer => writer.println(new java.util.Date)
    }
*** By-name parameters
    var assertionsEnabled = true
    def myAssert(predicate: () => Boolean) =
      if (assertionsEnabled && !predicate)
        throw new AssertionError

    myAssert(() => 5 > 3)

    def byNameAssert(predicate: => Boolean) =
      if (assertionsEnabled && !predicate)
        throw new AssertionError

    byNameAssert(5 > 3)

    def booleanAssert(predicate: Boolean) =
      if (assertionsEnabled && !predicate)
        throw new AssertionError

** Composition and Inheritance
   val column1 = elem("hello") above elem("***")
   val column2 = elem("***") above elem("world")
   column1 beside column2

   hello ***
    *** world
*** Abstract class
abstract class Element {
  def contents: Array[String]
}
**** no 'abstract' needed
*** Defining parameterless methods
abstract class Element {
  def contents: Array[String]
  def height: Int = contents.length
  def width: Int = if (height == 0) 0 else contents(0).length
}
**** Uniform access priciple (Meyer, Object-Oriented Software Construction)
     client code should not be affected by a decision
to implement an attribute as a field or method.
    it is encouraged style in Scala to define methods that take no
parameters and have no side effects as parameterless methods, i.e., leaving
off the empty parentheses.
*** Extend class
class ArrayElement(conts: Array[String]) extends Element {
  def contents: Array[String] = conts
}
*** Override
in Scala, fields and methods belong to the same namespace

class ArrayElement(conts: Array[String]) extends Element {
  val contents: Array[String] = conts
}

Generally, Scala has just two namespaces for definitions in place of Java’s
four. Java’s four namespaces are fields, methods, types, and packages. By
contrast, Scala’s two namespaces are:
• values (fields, methods, packages, and singleton objects)
• types (class and trait names)

*** Polymorphism and dynamic binding (subtyping polymorphism)
abstract class Element {
  def demo() {
    println("Element's implementation invoked")
  }
}
class ArrayElement extends Element {
  override def demo() {
    println("ArrayElement's implementation invoked")
  }
}
class LineElement extends ArrayElement {
  override def demo() {
    println("LineElement's implementation invoked")
  }
}
** Scala hierarchy
   Any, Nothing, Null
*** Any
**** == != equals (can == direct call equals?)
**** ## hashCode (## different with hashCode?)
**** toString
*** AnyVal and AnyRef
**** AnyVal
***** Byte, Short, Char, Int, Long, Float, Double, Boolean
      literal and final (can not new)
      42 max 41
      1 until 5
      1 to 5
***** Unit
**** AnyRef (java.lang.Object)
*** Null
    null: subclass of every reference class
*** Nothing
    subclass of every other thing
    (why we need nothing?)
** Traits
trait Philosophical {
  def philosophize() {
    println("I consume memory, therefore I am!")
  }
}

class Frog extends Philosophical {
  override def toString = "green"
}

class Animal
trait HasLegs
class Frog extends Animal with Philosophical with HasLegs {
  override def toString = "green"
}

**** Traits vs class
***** traits have no class parameters
***** super (statically bound in class, dynamically bound in traits)
**** Thin vs rich interfaces
***** interface injection (trade-off)
**** Stackable modifications
     A queue of int:
     1. Doubling
     2. Incrementing
     3. Filtering

abstract class IntQueue {
  def get(): Int
  def put(x: Int)
}
import scala.collection.mutable.ArrayBuffer
class BasicIntQueue extends IntQueue {
  private val buf = new ArrayBuffer[Int]
  def get() = buf.remove(0)
  def put(x: Int) { buf += x }
}

trait Doubling extends IntQueue {
  abstract override def put(x: Int) { super.put(2 * x) }
}

class MyQueue extends BasicIntQueue with Doubling

trait Incrementing extends IntQueue {
  abstract override def put(x: Int) { super.put(x + 1) }
}
trait Filtering extends IntQueue {
  abstract override def put(x: Int) {
    if (x >= 0) super.put(x)
  }
}

val queue = (new BasicIntQueue with Incrementing with Filtering)
queue.put(-1); queue.put(0); queue.put(1)
queue.get() // 1
queue.get() // 2

Order is important.

**** linearation
class Animal
trait Furry extends Animal
trait HasLegs extends Animal
trait FourLegged extends HasLegs
class Cat extends Animal with Furry with FourLegged

Animal ===> AnyRef ===> Any
Furry ===> Animal ===> AnyRef ===> Any
FourLegged ===> HasLegs ===> Furry ===> Animal ===> AnyRef ===> Any
Cat ==> FourLegs ==> HasLegs ==> Furry ==> Animal ==> AnyRef ==> Any

**** to trait, or not to trait
***** If the behavior will not be reused, then make it a concrete class.
***** If it might be reused in multiple, unrelated classes, make it a trait.
***** If you want to inherit from it in Java code, use an abstract class.
***** If you plan to distribute it in compiled form, and you expect outside groups to write classes inheriting from it, you might lean towards using an abstract class.
***** If efficiency is very important, lean towards using a class.
***** If you still do not know, after considering the above, then start by making it as a trait.
** Case class and pattern matching
** Type parameterize
** Abstract member
** Implicit conversions and parameters
** Implementing lists
** Actor and concurrency
* Resources
** [[https://wiki.scala-lang.org/display/SW/ScalaDays%2B2011%2BResources][Scala Days 2011]]
