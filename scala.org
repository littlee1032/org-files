* What is scala? Why scala?
** What is scala
*** scale language: scripts -> big system
**** seamless cooperate with java
**** static type + OOP + FP
** Why scala
*** consie: less words, consie meaning
    val capital = Map("US" -> "Washington")
    capital += ("Japan" -> "Tokyo")
    println(capital("US"))
*** flexible: less word change
*** barzaar: (cathedral vs barzaar)
**** new type
     def factorial(x: BigInt): BigInt =
         if (x == 0) 1 else x * factorial(x-1)
**** new control
     actor {
         var sum = 0
         loop {
             receive {
                 case Data(bytes) => sum += hash(bytes)
                 case GetSum(requester) => requester ! sum
             }
         }
     }
* Learn scala
** Value and variable
   val msg = "Hello World"
   var msg = "Hello World"
** Function
   def max(x: Int, y: Int): Int = {
       if (x > y) x
       else y
   }
   def max(x: Int, y: Int) = if (x > y) x else y
** Scripts
   #!/bin/sh
   exec scala "$0" "$@"
   !#
   println("Hello World")
** Loop
   var i=0
   while (i < args.length) {
       println(args(i))
       i += 1
   }
   args.foreach((arg: String) => println(arg))
   args.foreach(println)
** Parameterize arrays (mutable)
   val greetStrings = new Array[String](3)
   greetStrings(0) = "....." ....
   for (i <- 0 to 2)
     print(greetStrings(i))
   val numNames = Array("zero", "one", "two")
** List (immutable)
   val oneTwoThree = List(1, 2, 3)
   val four = List(4)
   val oneTwoThreeFour = oneTwoThree ::: four
   val oneTwoThree = 1 :: List(2, 3) = 1 :: 2 :: 3 :: Nil

   val thrill = "Will" :: "fill" :: "until" :: Nil
   thrill(2)
   thrill.count(s=>s.length == 4)
   thrill.drop(2)
   thrill.dropRight(2)
   thrill.exists(s=>s == "until")
   thrill.filter(s=>s.length == 4)
   thrill.forall(s=>s.endsWith("l"))
   thrill.foreach(s=>print(s)) ....
** Tuple (immutable)
   val pair = (99, "ninetynine")
   println(pair._1)
   println(pair._2)
** Sets and maps
*** Sets
**** scala.collection.immutable.Set, scala.collection.mutable.Set
**** scala.collection.immutable.HashSet, scala.collection.mutable.HashSet
     var jetSet = Set("Boeing", "Airbus")
     jetSet += "Aaaa"

     val movieSet = Set("Despicable Me", "Singing in the Rain")
     movieSet += "Flipped"
*** Map
**** scala.collection.immutable.Map, scala.collection.mutable.Map
**** scala.collection.immutable.HashMap, scala.collection.mutable.HashMap
     import scala.collection.mutable.Map
     val treasureMap = Map[Int, String]()
     treasureMap += (1 -> "Go to island.")
     treasureMap += (2 -> "Find big X on ground")
     treasureMap += (3 -> "Dig.")
** Functional style
   def printArgs(args: Array[String]): Unit = {
       var i = 0
       while (i < args.length) {
           println(args(i))
           i += 1
       }

       for (arg <- args)
           println(arg)

       args.foreach(println)
   }

** Classes, fields and methods
   class A {
       .....
   }
   val a = new A
   class A {
       private var sum = 0
       def add(b: Byte): Unit = {
           b = 1 //won't compile
           sum += b
       }

       def add(b: Byte): Unit = sum += b
       def add(b: Byte) { sum += b }
   }
** Singleton object
*** classes in Scala can not have static members. Scala has singleton objects
    object A {
        def someMethod() : Unit {
        }
    }
** Functions and Closures
*** Methods
*** Local functions (another solution for private)
    def processFile(filename: String, width: Int) {
      def processLine(filename: String/*, width: Int, line: String*/) {
        if (line.length > width)
          println(filename + ": " + line)
      }
      val source = Source.fromeFile(filename)
      for (line <- source.getLines()) {
        processLine(filename, width, line)
      }
    }
*** First-class functions
    var increase = (x: Int) => x + 1
    increase(10)
*** Short forms of function literals
    someNumbers.filter((x: Int) => x > 0)
    someNumbers.filter((x) => x > 0) (target typing)
    someNumbers.filter(x => x > 0)
*** Placeholder syntax
    someNumber.filter(_ > 0)
    val f = _ + _ (What's this?)
    val f = (_: Int) + (_:Int)
*** Parially applied functions
    def sum(a: Int, b: Int, c: Int) = a+b+c
    val a = sum _
    a(1, 2, 3)  // a.apply(1, 2, 3)
    val b = sum(1, _: Int, 3)
    b(2)
*** Closures
    var more = 1
    val addMore = (x: Int) => x + more
    addMore(10) // 11
    more = 9999
    addMore(10) // 10009

    val someNumbers = List(-11, -10, -5, 0 , 5, 10)
    var sum = 0
    someNumbers.foreach(sum += _)

    def makeIncreaser(more: Int) = (x: Int) => x + more
    makeIncreaser(10)
    makeIncreaser(1000)
*** Special function call forms
**** Repeated parameters
     def echo(args: String*) =
       for (arg <- args) println(arg)
**** Named arguments
     def speed(distance: Float, time: Float): Float = distance / time
     speed(distance = 100, time = 100)
     speed(time = 10, distance = 100)
**** Default parameter values
     def printTime(out: java.io.PrintStream = Console.out) = 
       out.println("time = " + System.currentTimeMillis())
*** Tail recursion
    def approximate(guess: Double): Double =
      if (isGoodEnough(guess)) guess
      else approximate(improve(guess))

    def bang(x: Int): Int =
      if (x == 0) throw new Exception("bang!")
      else bang(x-1)

    -g:notailcalls

**** limited: indirect, method rename
** Control Abstraction
*** high order function
   high order function ---> more oppotunity for reducing code duplication
   search problem:
   object FileMatcher {
     private def filesHere = (new java.io.File(".")).listFiles
     def filesEnding(query: String) =
       for (file <- filesHere; if file.getName.endsWith(query))
         yield file

     def filesContaining(query: String) = 
       for (file <- filesHere; if file.getName.contains(query))
         yield file

     def filesRegex(query: String) =
       for (file <- filesHere; if file.getName.matches(query))
         yield file
   }

   def fileMatching(query: String, method) =
     for (file <- filesHere; if file.getName.method(query))
       yield file

   Scala can not do this......

   def filesMathing(query: String, matcher: (String, String) => Boolean) = {
     for (file <- filesHere; if matcher(file.getName, query))
       yield file
   }

   def fileEnding(query: String) =
     filesMatching(query, _.endsWith(_))

   def containsNeg(name: List[Int]): Boolean = {
     var exists = false
     for (num <- nums)
       if (num < 0)
         exists = true
     exists
   }

   def containsNeg(nums: List[Int]) = nums.exists(_ < 0)

*** Curring
    def plainOldSum(x: Int, y: Int) = x + y

    def curriedSum(x: Int)(y: Int) = x + y

    def withPrintWriter(file: File, op: PrintWriter => Unit) {
      val writer = new PrintWriter(file)
      try {
        op(writer)
      } finally {
        writer.close()
      }
    }

    withPrintWriter(
      new File("data.txt"),
      writer => writer.println(new java.util.Date)
    )

    println {"Hello, world!"}

    val file = new File("data.txt")
    withPrintWriter(file) {
      writer => writer.println(new java.util.Date)
    }
*** By-name parameters
    var assertionsEnabled = true
    def myAssert(predicate: () => Boolean) =
      if (assertionsEnabled && !predicate)
        throw new AssertionError

    myAssert(() => 5 > 3)

    def byNameAssert(predicate: => Boolean) =
      if (assertionsEnabled && !predicate)
        throw new AssertionError

    byNameAssert(5 > 3)

    def booleanAssert(predicate: Boolean) =
      if (assertionsEnabled && !predicate)
        throw new AssertionError

** Composition and Inheritance
   val column1 = elem("hello") above elem("***")
   val column2 = elem("***") above elem("world")
   column1 beside column2

   hello ***
    *** world
*** Abstract class
abstract class Element {
  def contents: Array[String]
}
**** no 'abstract' needed
*** Defining parameterless methods
abstract class Element {
  def contents: Array[String]
  def height: Int = contents.length
  def width: Int = if (height == 0) 0 else contents(0).length
}
**** Uniform access priciple (Meyer, Object-Oriented Software Construction)
     client code should not be affected by a decision
to implement an attribute as a field or method.
    it is encouraged style in Scala to define methods that take no
parameters and have no side effects as parameterless methods, i.e., leaving
off the empty parentheses.
*** Extend class
class ArrayElement(conts: Array[String]) extends Element {
  def contents: Array[String] = conts
}
*** Override
in Scala, fields and methods belong to the same namespace

class ArrayElement(conts: Array[String]) extends Element {
  val contents: Array[String] = conts
}

Generally, Scala has just two namespaces for definitions in place of Java’s
four. Java’s four namespaces are fields, methods, types, and packages. By
contrast, Scala’s two namespaces are:
• values (fields, methods, packages, and singleton objects)
• types (class and trait names)

*** Polymorphism and dynamic binding (subtyping polymorphism)
abstract class Element {
  def demo() {
    println("Element's implementation invoked")
  }
}
class ArrayElement extends Element {
  override def demo() {
    println("ArrayElement's implementation invoked")
  }
}
class LineElement extends ArrayElement {
  override def demo() {
    println("LineElement's implementation invoked")
  }
}
** Scala hierarchy
   Any, Nothing, Null
*** Any
**** == != equals (can == direct call equals?)
**** ## hashCode (## different with hashCode?)
**** toString
*** AnyVal and AnyRef
**** AnyVal
***** Byte, Short, Char, Int, Long, Float, Double, Boolean
      literal and final (can not new)
      42 max 41
      1 until 5
      1 to 5
***** Unit
**** AnyRef (java.lang.Object)
*** Null
    null: subclass of every reference class
*** Nothing
    subclass of every other thing
    (why we need nothing?)
** Traits
** Case class and pattern matching
*** A simple sample
abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String, left: Expr, right: Expr) extends Expr
**** a factory method with name of the class
val op = Binary("+", Number(1), Var("x"))
**** all argument in the parameter list get a val prefix
v.name, op.operator
**** compiler adds hashCode, toString and equals
**** copy method
***** make a new instance
***** use the same value if no specifiy
op.copy(operator = "-")
*** pattern matching
simplification rules:
def simplifyTop(expr: Expr): Expr = expr match {
  case UnOp("-", UnOp("-", e)) => e
  // Double negation
  case BinOp("+", e, Number(0)) => e // Adding zero
  case BinOp("*", e, Number(1)) => e // Multiplying by one
  case _ => expr 
}
*** kinds of patterns
**** wild pattern
expr match {
 case BinOp(_, _, _) => println(expr +" is a binary operation")
 case _ => println("It's something else")
}
**** constant pattern
def describe(x: Any) = x match {
  case 5 => "five"
  case true => "truth"
  case "hello" => "hi!"
  case Nil => "the empty list"
  case _ => "something else"
}
**** variable pattern
expr match {
  case 0 => "zero"
  case somethingElse => "not zero: "+ somethingElse
}
**** constructor pattern (deep)
expr match {
  case BinOp("+", e, Number(0)) => println("a deep match")
  case _ =>
}
**** sequence pattern
expr match {
  case List(0, _, _) => println("found it")
  case _ =>
}
expr match {
  case List(0, _*) => println("found it")
  case _ =>
}
**** tuple pattern
expr match {
  case (a, b, c) => println("matched "+ a + b + c)
  case _ =>
}
**** typed pattern
def generalSize(x: Any) = x match {
  case s: String => s.length
  case m: Map[_, _] => m.size
  case _ => -1
}
def isIntIntMap(x: Any) = x match {
  case m: Map[Int, Int] => true
  case _ => false
} ?
def isStringArray(x: Any) = x match {
  case a: Array[String] => "yes"
  case _ => "no"
}
**** variable binding
expr match {
  case UnOp("abs", e @ UnOp("abs", _)) => e
  case _ =>
}
*** pattern guards
def simplifyAdd(e: Expr) = e match {
  case BinOp("+", x, x) => BinOp("*", x, Number(2))
  case _ => e
} ?
def simplifyAdd(e: Expr) = e match {
  case BinOp("+", x, y) if x == y => BinOp("*", x, Number(2))
  case _ => e
}


** Type parameterize
** Abstract member
** Implicit conversions and parameters
** Implementing lists
** Actor and concurrency
* Resources
** [[https://wiki.scala-lang.org/display/SW/ScalaDays%2B2011%2BResources][Scala Days 2011]]
